# JavaScript 超大整数相加的解决方案

Js 和任何一门语言一样，对其数值的范围有限制。

```
Number.MAX_VALUE // 1.7976931348623157e+308
Number.MAX_SAFE_INTEGER // 9007199254740991
Number.MIN_VALUE // 5e-324
Number.MIN_SAFE_INTEGER // -9007199254740991
```

如果我们想要对一个超大的整数( `> Number.MAX_SAFE_INTEGER` )进行加法运算，  
但是又想输出一般形式，那么使用 `+` 是无法达到的，  
一旦数字超过 `Number.MAX_SAFE_INTEGER` 数字会被立即转换为科学计数法，  
并且数字精度相比以前将会有误差。在此时就需要自己实现一套加法算法。  

#### 算法

```
function sumBigNumber(a, b) {
  var res = '',
    temp = 0;
  a = a.split('');
  b = b.split('');
  while (a.length || b.length || temp) {
    temp += ~~a.pop() + ~~b.pop();
    res = (temp % 10) + res;
    temp = temp > 9;
  }
  return res.replace(/^0+/, '');
}
```

#### 解释

* 首先我们用字符串的形势来保存大数，就保证了其在数学表示上不会发生变化
* 初始化 `res, temp` 变量来保存中间计算的结果，在将两个字符串 `split` 为数组，以便我们进行每一位的运算
* 循环的第一次就是进行 "个位" 的运算，将二者最末尾的两个数相加，由于每一位数字是0 - 9，所以需要进行进位，在进过取余数操作后，将结果保留在个位。
* 判断 `temp` 是否大于 10，若是则将 `temp` 赋值为 `true` ，等等，为什么要赋值成布尔值，不要着急，魔法即将发生。
* 在两个大数中的一个还有数字没有参与运算，或者前一次运算发生进位后，进行下一次循环。
* 接着除了对新的两个数字相加还要加上 `temp` ，若上次发生了进位，则此时 `temp` 为 `true` ，Js因为存在隐式转换，所以 `true` 转换为 1，我们借用 Js 的类型转换，完成了逻辑上的逢10进1操作。Amazing
* 接下来就是重复上述的操作，直到计算结束。

#### 例子

```
sumBigNumber('100000000000002222', '111111'); // 100000000000113333
sumBigNumber('3782647863278468012934670', '23784678091370408971329048718239749083'); // 23784678091374191619192327186252683753
```
